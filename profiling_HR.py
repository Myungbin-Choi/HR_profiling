# -*- coding: utf-8 -*-
"""Kaggle_HR.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OgNwgv0GcNpFf-CzYNQz1-omvtDQMvXQ

# 0. 환경설정 및 워크벤치 세팅

## 워크벤치 세팅
"""

! pip install pandas sqlalchemy pymysql -q

user = 'root'
password = 'password'
host = 'localhost'
port = 3306
database = 'Kaggle_HR'

from sqlalchemy import create_engine

# 1) 커넥션 URL 생성
url = f"mysql+pymysql://{user}:{password}@{host}:{port}/{database}?charset=utf8mb4"
engine = create_engine(url)

data_path = 'wfs_behaviors_and_records_508p-546d-98r_20220722173739.csv'
hr_df = pd.read_csv(data_path, encoding='cp1252')

hr_df.to_sql('hr_table', engine, if_exists='append', index=False)

"""## VSCODE 세팅"""

! pip install koreanize_matplotlib

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import koreanize_matplotlib

data_path = 'wfs_behaviors_and_records_508p-546d-98r_20220722173739.csv'
hr_df = pd.read_csv(data_path, encoding='cp1252')

"""## 구글 세팅"""

from google.colab import drive
drive.mount('/content/drive')

! pip install koreanize_matplotlib

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import koreanize_matplotlib

data_path = '/content/drive/MyDrive/데이터분석_개인/wfs_behaviors_and_records_508p-546d-98r_20220722173739.csv'
hr_df = pd.read_csv(data_path, encoding='cp1252')

"""# 1. 우리 회사 직원 현황

## 회사 현황 확인
"""

hr_df.head(2)

# 직원 기초 현황
unique_df = hr_df.drop_duplicates(subset='sub_ID')

total_count = unique_df['sub_ID'].nunique()
avg_age = unique_df['sub_age'].mean()
total_female = (unique_df['sub_sex'] == 'F').sum()  # () 조건이 참인 경우 1
total_male = (unique_df['sub_sex'] == 'M').sum()

print(f'전체 인원: {total_count}명')
print(f'나이 평균: {avg_age:.1f}')
print(f'여성 직원 수: {total_female}명')
print(f'남성 직원 수: {total_male}명')

# 직원 역량 평균 확인
avg_health = unique_df['sub_health_h'].mean()
avg_commitment = unique_df['sub_commitment_h'].mean()
avg_perceptiveness = unique_df['sub_perceptiveness_h'].mean()
avg_dexterity = unique_df['sub_dexterity_h'].mean()
avg_sociality = unique_df['sub_sociality_h'].mean()
avg_goodness = unique_df['sub_goodness_h'].mean()
avg_strength = unique_df['sub_strength_h'].mean()
avg_openmindness = unique_df['sub_openmindedness_h'].mean()

print('우리 회사의 직원 역량 평균')
print(f'건강: {avg_health:.3f}')
print(f'헌신도: {avg_commitment:.3f}')
print(f'인지력: {avg_perceptiveness:.3f}')
print(f'손재주: {avg_dexterity:.3f}')
print(f'사회성: {avg_sociality:.3f}')
print(f'선량함: {avg_goodness:.3f}')
print(f'힘: {avg_strength:.3f}')
print(f'수용성: {avg_openmindness:.3f}')

# shift, team 별 현황
shift_info = unique_df.groupby(['sub_shift', 'sub_team']).agg({
	'sub_ID': 'nunique',
	'sub_age' : 'mean',
  	'sub_sex': [
    	('여성', lambda x: (x=='F').sum()),
   		('남성', lambda x: (x=='M').sum())
  ]
})

shift_info.reset_index(inplace=True)
shift_info.columns = ['shift', 'team', '인원수', '평균 나이', '여성', '남성']
print(shift_info)

# shift, team 별 역량 평균
shift_info = unique_df.groupby(['sub_shift', 'sub_team']).agg({
  'sub_health_h':'mean',
  'sub_commitment_h' :'mean',
  'sub_perceptiveness_h':'mean',
  'sub_dexterity_h':'mean',
  'sub_sociality_h':'mean',
  'sub_goodness_h':'mean',
  'sub_strength_h':'mean',
  'sub_openmindedness_h':'mean'
})

shift_info.reset_index(inplace=True)
shift_info.columns = ['shift', 'team', '건강', '헌신도', '인지력', '손재주', '사회성', '선량함', '힘', '수용성']
print(shift_info)

"""## 생산성 변화"""

recent_df = recent_df[recent_df['event_date'].dt.year == 2022]

recent_df['event_month'] = recent_df['event_date'].dt.to_period('M').dt.to_timestamp()

group_efficacy = recent_df.groupby(['event_month', 'performance_group'])['actual_efficacy_h'].mean().reset_index()
group_efficacy

plt.figure(figsize=(12, 6))
line_plot = sns.lineplot(data=group_efficacy, x='event_month', y='actual_efficacy_h', hue='performance_group', marker='o')

for line in group_efficacy['performance_group'].unique():
    group_data = group_efficacy[group_efficacy['performance_group'] == line]
    for x, y in zip(group_data['event_month'], group_data['actual_efficacy_h']):
        plt.text(x, y + 0.05, f'{y:.2f}', ha='center', fontsize=9)

plt.grid(True, which='major', axis='both', linestyle='--', alpha=0.5)
plt.title('Efficacy change')
plt.xlabel('month')
plt.ylabel('efficacy')
plt.legend(title='performance group')
plt.tight_layout()
plt.show()

plt.figure(figsize=(12, 6))
sns.lineplot(data=recent_df, x='event_month', y='actual_efficacy_h', marker='o')
plt.grid(True, which='major', axis='both', linestyle='--', alpha=0.5)
plt.title('Efficacy change')
plt.xlabel('month')
plt.ylabel('efficacy')
plt.tight_layout()
plt.show()

recent_df.groupby(by='performance_group')['actual_efficacy_h'].mean()

"""# 2. 고성과자 확인
- 고성과자 기준 : event_date 기준 최근 6개월 이내, efficacy 평균, 상위 20%

## performance group 분류
"""

hr_df.head(2)

hr_df['behav_comptype_h'].value_counts()

hr_df['event_date'] = pd.to_datetime(hr_df['event_date'])

from dateutil.relativedelta import relativedelta

latest_date = hr_df['event_date'].max()
six_month_ago = latest_date - relativedelta(months=6)
recent_df = hr_df[hr_df['event_date'] >= six_month_ago]

recent_df.shape

hr_df.shape

recent_df.head(2)

recent_df['behav_comptype_h'].value_counts()

# sub_ID별 actual_efficacy_h 평균을 기준으로 성과그룹 분류 필요

# 일단 sub_ID별 생산성 평균을 구하기
avg_efficacy = recent_df.groupby('sub_ID').agg({'actual_efficacy_h':'mean'})

# 생산성 평균을 기준으로 performance_group 만들기
avg_efficacy['performance_group'] = pd.qcut(
    avg_efficacy['actual_efficacy_h'],
    q=5,
    labels=[5,4,3,2,1]
)

avg_efficacy.reset_index(inplace=True)

# recent_df에 병합
recent_df = recent_df.merge(avg_efficacy[['sub_ID', 'performance_group']], on='sub_ID', how='left')

"""## 그룹별 역량 차이 확인"""

perf_group_competency = recent_df.groupby(['performance_group']).agg({
  'sub_age':'mean',
  'sub_health_h':'mean',
  'sub_commitment_h' :'mean',
  'sub_perceptiveness_h':'mean',
  'sub_dexterity_h':'mean',
  'sub_sociality_h':'mean',
  'sub_goodness_h':'mean',
  'sub_strength_h':'mean',
  'sub_openmindedness_h':'mean',
  'actual_efficacy_h': 'mean'
})

perf_group_competency

from scipy.stats import f_oneway

# 역량 컬럼 리스트
competency_cols = [
    'sub_age', 'sub_health_h', 'sub_commitment_h', 'sub_perceptiveness_h',
    'sub_dexterity_h', 'sub_sociality_h', 'sub_goodness_h',
    'sub_strength_h', 'sub_openmindedness_h'
]

# 각 컬럼에 대해 ANOVA 수행
anova_results = {}
for col in competency_cols:
    groups = [group[col].dropna().values for name, group in recent_df.groupby('performance_group')]
    f_stat, p_val = f_oneway(*groups)
    anova_results[col] = {'F-statistic': f_stat, 'p-value': p_val}

# 결과 확인
import pandas as pd
anova_df = pd.DataFrame(anova_results).T
anova_df.sort_values('p-value')

"""<mark> openmindedness는 그룹별로 유의미한 차이가 있다."""

# Tukey HSD 사후검정 : 성과 그룹 간 개방성 지표 평균 차이가 유의미한지 비교
from statsmodels.stats.multicomp import pairwise_tukeyhsd

tukey = pairwise_tukeyhsd(endog=recent_df['sub_openmindedness_h'],
                          groups=recent_df['performance_group'],
                          alpha=0.05)
print(tukey.summary())

"""| 컬럼                 | 의미                             |
| ------------------ | ------------------------------ |
| `group1`, `group2` | 비교한 성과 그룹                      |
| `meandiff`         | 그룹 간 평균 차이 (`group2 - group1`) |
| `p-adj`            | 조정된 p-value (다중비교 보정된 값)       |
| `lower`, `upper`   | 평균 차이의 신뢰구간 (95%)              |
| `reject`           | `True`면 유의미한 차이 있음 (귀무가설 기각)   |

```python
- 고성과자 그룹일수록 sub_openmindedness_h가 낮은 경향일 수 있음
- 특히 2번 그룹이 개방성이 가장 높고, 3번이 낮음
- 모든 그룹 간 차이가 유의미하기 때문에, 선형적이진 않아도 계층적 구분이 뚜렷하다고 해석 가능
```
"""

import seaborn as sns
import matplotlib.pyplot as plt

sns.boxplot(x='performance_group', y='sub_openmindedness_h', data=recent_df, order=[1,2,3,4,5])
plt.title('개방성 점수 분포 (성과그룹별)')
plt.xlabel('Performance Group (1=Best)')
plt.ylabel('Openmindedness')
plt.show()

"""## 그룹별 슈퍼바이저 차이 확인"""

recent_df['performance_group'] = recent_df['performance_group'].astype(int)

recent_df.columns

perf_group_sup = recent_df.groupby(['performance_group']).agg({
  'sup_age':'mean',
  'sup_sub_age_diff':'mean',
  'sup_commitment_h':'mean',
  'sup_perceptiveness_h':'mean',
  'sup_goodness_h':'mean'
})


perf_group_sup

# 역량 컬럼 리스트
sup_cols = ['sup_age', 'sup_sub_age_diff', 'sup_commitment_h','sup_perceptiveness_h', 'sup_goodness_h']

# 각 컬럼에 대해 ANOVA 수행
anova_results = {}
for col in sup_cols:
    groups = [group[col].dropna().values for name, group in recent_df.groupby('performance_group')]
    f_stat, p_val = f_oneway(*groups)
    anova_results[col] = {'F-statistic': f_stat, 'p-value': p_val}

# 결과 확인
import pandas as pd
anova_df = pd.DataFrame(anova_results).T
anova_df.sort_values('p-value')

tukey = pairwise_tukeyhsd(endog=recent_df['sup_goodness_h'],
                          groups=recent_df['performance_group'],
                          alpha=0.05)
print(tukey.summary())

recent_df.isnull().sum()

# nan 값 제외하고 분석
df_tukey = recent_df[['sup_goodness_h', 'performance_group']].dropna()
tukey = pairwise_tukeyhsd(endog=df_tukey['sup_goodness_h'],
                          groups=df_tukey['performance_group'],
                          alpha=0.05)
print(tukey.summary())

sns.boxplot(x='performance_group', y='sup_goodness_h', data=recent_df)
plt.title('sup_goodness_h by Performance Group')
plt.show()

"""# 3. 생산성과 관련 있는 지표 확인

## 전처리
"""

recent_df.columns

efficacy_df = recent_df[(recent_df['behav_comptype_h'] == 'Efficacy')]

efficacy_df.shape

efficacy_df.drop(columns=['sub_fname', 'sub_lname', 'sub_shift', 'sub_team', 'sub_role', 'sub_coll_IDs', 'sub_workstyle_h', 'sup_ID', 'sup_fname', 'sup_lname', 'sup_sex','sup_role', 'event_week_in_series','event_day_in_series',  'behav_comptype_h', 'behav_cause_h',  'record_comptype', 'record_cause', 'recorded_efficacy', 'recorded_note_from_sup', 'record_conf_matrix_h'], inplace=True)

efficacy_df.head(2)

# 남자 0, 여자 1
efficacy_df['sub_sex'] = (efficacy_df['sub_sex'] == 'F').astype(int)

# 요일 숫자로 변환
weekday_mapping = {
    'Monday': 1,
    'Tuesday': 2,
    'Wednesday': 3,
    'Thursday': 4,
    'Friday': 5,
    'Saturday': 6
}

efficacy_df['event_weekday_name'] = efficacy_df['event_weekday_name'].map(weekday_mapping)

efficacy_df.dtypes

"""## 상관관계 확인"""

plt.figure(figsize=(15, 15))
sns.heatmap(efficacy_df.corr(), annot=True, fmt='.2f', cmap='coolwarm')
plt.show()

plt.figure(figsize=(5, 5))
sns.scatterplot(data=efficacy_df, x='sub_health_h', y='actual_efficacy_h')
plt.show()

"""### 개인의 역량과 생산성 평균 상관관계"""

# sub_id별로 역량, efficacy 평균을 낸 다음 해당 데이터로 상관관계 분석
sub_com_eff_avg = recent_df.groupby(by='sub_ID')[['sub_health_h', 'sub_commitment_h', 'sub_perceptiveness_h', 'sub_dexterity_h', 'sub_sociality_h', 'sub_goodness_h', 'sub_strength_h', 'sub_openmindedness_h', 'actual_efficacy_h']].mean().reset_index()
sub_com_eff_avg.head(2)

plt.figure(figsize=(7, 7))
sns.heatmap(sub_com_eff_avg.corr(), annot=True, fmt='.2f', cmap='coolwarm')
plt.show()

plt.figure(figsize=(5, 5))
sns.scatterplot(data=sub_com_eff_avg, x='sub_health_h', y='actual_efficacy_h', color='blue')
sns.regplot(data=sub_com_eff_avg, x='sub_health_h', y='actual_efficacy_h',
            scatter=False, line_kws={'color': 'red'})
plt.show()

x_vars = [
    'sub_health_h', 'sub_commitment_h', 'sub_perceptiveness_h',
    'sub_dexterity_h', 'sub_sociality_h', 'sub_goodness_h',
    'sub_strength_h', 'sub_openmindedness_h'
]

# 그래프 사이즈 설정
plt.figure(figsize=(15, 15))

# 각 변수에 대해 subplot으로 그림
for i, x in enumerate(x_vars):
    plt.subplot(3, 3, i + 1)  # 3행 3열 배열, 인덱스는 1부터 시작
    sns.scatterplot(data=sub_com_eff_avg, x=x, y='actual_efficacy_h', color='blue')
    sns.regplot(data=sub_com_eff_avg, x=x, y='actual_efficacy_h',
                scatter=False, line_kws={'color': 'red'})
    plt.title(f'{x} vs actual_efficacy_h')

plt.tight_layout()
plt.show()

"""### 차원 축소 후 시각화"""

from sklearn.decomposition import PCA

pca = PCA(n_components=1)
sub_com_eff_avg['pca_comp'] = pca.fit_transform(sub_com_eff_avg[x_vars])
sns.regplot(data=sub_com_eff_avg, x='pca_comp', y='actual_efficacy_h')

"""### 예측모델 기반 피처 중요도 분석"""

from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import train_test_split

X = sub_com_eff_avg[x_vars]
y = sub_com_eff_avg['actual_efficacy_h']

model = RandomForestRegressor()
model.fit(X, y)

# 중요도 시각화
importances = pd.Series(model.feature_importances_, index=x_vars)
importances.sort_values().plot(kind='barh')

"""### 클러스터링 기반"""

from sklearn.cluster import KMeans

kmeans = KMeans(n_clusters=3)
sub_com_eff_avg['cluster'] = kmeans.fit_predict(sub_com_eff_avg[x_vars])
sns.boxplot(data=sub_com_eff_avg, x='cluster', y='actual_efficacy_h')

"""# 4. 시간에 따른 성과 변화 분석

- 어떤 순서로 해야하지?
    - 1) recent_df['performance_group'] = 1인 데이터 추출
    - 2) 1)의 성과가 가장 좋은 sub_ID의 event_date, event_week, event_weekday_name, behav_comptype_h, actual_efficacy_h 여정 확인 & 시각화
    - 3) 2)에서 성과가 가장 좋은 순간 앞뒤의 이벤트 확인
    - 4) 2)에서 성과가 떨어지는 순간 앞뒤의 이벤트 확인
    - 5) 위의 순서를 여러 명의 sub_ID의 여정을 반복 추출하면서 일반화할 수 있는 결론 추출

## 생산성 1위
"""

# 1) recent_df['performance_group'] = 1인 데이터 추출
high_performers_df = recent_df[(recent_df['performance_group'] == 1)]
high_performers_df.shape

# 2) 성과가 가장 높은 id 확인
top_performer = high_performers_df.loc[high_performers_df['actual_efficacy_h'].idxmax()]
top_performer_id = top_performer['sub_ID']
print(top_performer_id)

# 3) top_performer sub_ID의 event_date, event_week, event_weekday_name, behav_comptype_h, actual_efficacy_h 여정 확인 & 시각화
top_performer_df = high_performers_df[(high_performers_df['sub_ID'] == top_performer_id)]
top_performer_df = top_performer_df[['sub_ID', 'sub_coll_IDs', 'sub_colls_same_sex_prtn', 'event_date', 'event_weekday_num', 'event_weekday_name', 'behav_comptype_h', 'behav_cause_h', 'actual_efficacy_h']]

top_performer_df.shape

top_performer_df.head(20)

# behave_comptype_h 가 Presence인 항목 삭제
top_performer_df = top_performer_df[(top_performer_df['behav_comptype_h'] != 'Presence')]
top_performer_df.reset_index(inplace=True)
top_performer_df.shape

top_performer_df.head(50)

top_performer_df['behav_comptype_h'].value_counts()

avg_efficacy = top_performer_df['actual_efficacy_h'].mean()
avg_efficacy

# actual_efficacy_h 시각화

plt.figure(figsize=(18, 5))
sns.lineplot(data=top_performer_df, x='event_date', y='actual_efficacy_h')

# 평균선 추가
avg_efficacy = top_performer_df['actual_efficacy_h'].mean()
plt.axhline(avg_efficacy, color='green', linestyle='--', label=f'Mean ({avg_efficacy:.2f})')

plt.title('Actual Efficacy Over Time for Top Performer')
plt.xlabel('Event Date', fontsize=14)
plt.ylabel('Actual Efficacy (h)', fontsize=14)
plt.grid(True, linestyle='--', alpha=0.5)
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

# Teamwork 앞뒤로 efficacy 확인
teamwork_idxs = top_performer_df[top_performer_df['behav_comptype_h'] == 'Feat'].index

# 5일 전후 생산성 추출
results = []

for idx in teamwork_idxs:
    # 범위를 벗어나지 않는지 확인
    if idx >= 5 and idx <= len(top_performer_df) - 6:
        pre_efficacy = top_performer_df.loc[idx-5:idx-1, 'actual_efficacy_h'].dropna()
        post_efficacy = top_performer_df.loc[idx+1:idx+5, 'actual_efficacy_h'].dropna()

        if len(pre_efficacy) > 0 and len(post_efficacy) > 0:
            results.append({
                'event_date': top_performer_df.loc[idx, 'event_date'],
                'pre_mean': pre_efficacy.mean(),
                'post_mean': post_efficacy.mean(),
                'change': post_efficacy.mean() - pre_efficacy.mean()
            })

change_df = pd.DataFrame(results)

print("평균 변화량 (5일 후 - 5일 전):", change_df['change'].mean())

"""<mark> teamwork 후 생산성이 떨어지는 경향이 있으나 크지 않음"""

plt.figure(figsize=(10, 6))
sns.histplot(change_df['change'], kde=True)
plt.axvline(change_df['change'].mean(), color='red', linestyle='--', label='평균 변화량')
plt.title("Teamwork 이벤트 전후 (5일 간) actual_efficacy 변화량 분포")
plt.xlabel("변화량 (Post - Pre)")
plt.legend()
plt.show()

# 이벤트별 생산성 변화량 비교
event_types = top_performer_df['behav_comptype_h'].dropna().unique()
all_results = []

for event in event_types:
    idxs = top_performer_df[top_performer_df['behav_comptype_h'] == event].index
    for idx in idxs:
        if idx >= 5 and idx <= len(top_performer_df) - 6:
            pre = top_performer_df.loc[idx-5:idx-1, 'actual_efficacy_h'].dropna()
            post = top_performer_df.loc[idx+1:idx+5, 'actual_efficacy_h'].dropna()
            if len(pre) > 0 and len(post) > 0:
                all_results.append({
                    'event': event,
                    'pre_mean': pre.mean(),
                    'post_mean': post.mean(),
                    'change': post.mean() - pre.mean()
                })

event_change_df = pd.DataFrame(all_results)

event_change_df

# 이벤트별 생산성 변화량 시각화
plt.figure(figsize=(12, 6))
sns.boxplot(data=event_change_df, x='event', y='change', palette='Set2')
plt.axhline(0, color='gray', linestyle='--')
plt.title('Change in Productivity (Efficacy) by Event Type', fontsize=14)
plt.ylabel('Post - Pre Efficacy Change')
plt.xlabel('Event Type')
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

"""- 0보다 위 → 이벤트 후 생산성 상승
- 0보다 아래 → 이벤트 후 생산성 하락
- 박스 길이 → 일관성(변동성)
"""

# 이벤트별 사전-사후 분포
feat_df = event_change_df[event_change_df['event'] == 'Sacrifice']

sns.kdeplot(feat_df['pre_mean'], label='Before', fill=True)
sns.kdeplot(feat_df['post_mean'], label='After', fill=True)
plt.title('Distribution of Efficacy Before and After "Sacrifice" Event')
plt.xlabel('Efficacy')
plt.legend()
plt.tight_layout()
plt.show()

"""## 생산성 2위"""

df = high_performers_df.groupby(by='sub_ID')['actual_efficacy_h'].mean().sort_values(ascending=False).reset_index()
df.head(15)

# 3) top_performer sub_ID의 event_date, event_week, event_weekday_name, behav_comptype_h, actual_efficacy_h 여정 확인 & 시각화
second_performer_df = high_performers_df[(high_performers_df['sub_ID'] == 98000294)]
second_performer_df = second_performer_df[['sub_ID', 'event_date', 'event_weekday_num', 'event_weekday_name', 'behav_comptype_h', 'behav_cause_h', 'actual_efficacy_h']]

second_performer_df.shape

# behave_comptype_h 가 Presence인 항목 삭제
second_performer_df = second_performer_df[(second_performer_df['behav_comptype_h'] != 'Presence')]
second_performer_df.reset_index(inplace=True)
second_performer_df.shape

# actual_efficacy_h 시각화

avg_efficacy = second_performer_df['actual_efficacy_h'].mean()
avg_efficacy

plt.figure(figsize=(18, 5))
sns.lineplot(data=second_performer_df, x='event_date', y='actual_efficacy_h')

# 평균선 추가
avg_efficacy = second_performer_df['actual_efficacy_h'].mean()
plt.axhline(avg_efficacy, color='green', linestyle='--', label=f'Mean ({avg_efficacy:.2f})')

plt.title('Actual Efficacy Over Time for Second Performer')
plt.xlabel('Event Date', fontsize=14)
plt.ylabel('Actual Efficacy (h)', fontsize=14)
plt.grid(True, linestyle='--', alpha=0.5)
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

second_performer_df['behav_comptype_h'].value_counts()

# Teamwork 앞뒤로 efficacy 확인
teamwork_idxs = second_performer_df[second_performer_df['behav_comptype_h'] == 'Absence'].index

# 5일 전후 생산성 추출
results = []

for idx in teamwork_idxs:
    # 범위를 벗어나지 않는지 확인
    if idx >= 5 and idx <= len(second_performer_df) - 6:
        pre_efficacy = second_performer_df.loc[idx-5:idx-1, 'actual_efficacy_h'].dropna()
        post_efficacy = second_performer_df.loc[idx+1:idx+5, 'actual_efficacy_h'].dropna()

        if len(pre_efficacy) > 0 and len(post_efficacy) > 0:
            results.append({
                'event_date': second_performer_df.loc[idx, 'event_date'],
                'pre_mean': pre_efficacy.mean(),
                'post_mean': post_efficacy.mean(),
                'change': post_efficacy.mean() - pre_efficacy.mean()
            })

change_df = pd.DataFrame(results)

print("평균 변화량 (5일 후 - 5일 전):", change_df['change'].mean())

plt.figure(figsize=(10, 6))
sns.histplot(change_df['change'], kde=True)
plt.axvline(change_df['change'].mean(), color='red', linestyle='--', label='평균 변화량')
plt.title("결근 전후 (5일 간) actual_efficacy 변화량 분포")
plt.xlabel("변화량 (Post - Pre)")
plt.legend()
plt.show()

"""# 6. 특정 이벤트 빈도 기준 생산성 추이"""

# 고성과그룹의 직원별 Teamwork/Sacrifice 이벤트 수 세기
event_counts = high_performers_df[high_performers_df['behav_comptype_h'].isin(['Teamwork', 'Sacrifice'])] \
    .groupby(['sub_ID', 'behav_comptype_h']) \
    .size().unstack(fill_value=0).reset_index()

event_counts

# 상위 그룹 기준 정의
sacrifice_threshold = event_counts['Sacrifice'].quantile(0.75)
teamwork_threshold = event_counts['Teamwork'].quantile(0.75)

# 그룹 라벨링
event_counts['high_sacrifice'] = event_counts['Sacrifice'] >= sacrifice_threshold
event_counts['high_teamwork'] = event_counts['Teamwork'] >= teamwork_threshold

merged = high_performers_df.merge(event_counts[['sub_ID', 'high_sacrifice', 'high_teamwork']], on='sub_ID', how='left')

# 날짜 기준 생산성 평균 (예: 주 단위)
merged['event_week'] = pd.to_datetime(merged['event_date']).dt.to_period('W').dt.to_timestamp()

# Sacrifice 기준 비교
sac_curve = merged.groupby(['event_week', 'high_teamwork'])['actual_efficacy_h'].mean().reset_index()

plt.figure(figsize=(14, 6))
sns.lineplot(data=sac_curve, x='event_week', y='actual_efficacy_h', hue='high_teamwork', palette='Set2')
plt.title('Long-term Productivity Comparison: High vs Low teamwork')
plt.ylabel('Avg Actual Efficacy (h)')
plt.xlabel('Week')
plt.legend(title='High teamwork')
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

"""## 상위 25%, 하위 25% 비교

### 팀워크
"""

# 상하위 25% 임계값 계산
teamwork_q75 = event_counts['Teamwork'].quantile(0.75)
teamwork_q25 = event_counts['Teamwork'].quantile(0.25)

sacrifice_q75 = event_counts['Sacrifice'].quantile(0.75)
sacrifice_q25 = event_counts['Sacrifice'].quantile(0.25)

# teamwork 상하위 그룹
def teamwork_group(val):
    if val >= teamwork_q75:
        return 'high'
    elif val <= teamwork_q25:
        return 'low'
    else:
        return 'middle'

event_counts['teamwork_group'] = event_counts['Teamwork'].apply(teamwork_group)

# 병합
merged = high_performers_df.merge(event_counts[['sub_ID', 'teamwork_group']], on='sub_ID', how='left')

# 주 단위 주차
merged['event_week'] = pd.to_datetime(merged['event_date']).dt.to_period('W').dt.to_timestamp()

# 상하위 그룹만 필터링
filtered = merged[merged['teamwork_group'].isin(['high', 'low'])]

# 그룹별 주차별 생산성 평균
curve = filtered.groupby(['event_week', 'teamwork_group'])['actual_efficacy_h'].mean().reset_index()

plt.figure(figsize=(14, 6))
sns.lineplot(data=curve, x='event_week', y='actual_efficacy_h', hue='teamwork_group', palette='Set1')
plt.title('Productivity Over Time: High vs Low Teamwork Group')
plt.ylabel('Avg Actual Efficacy (h)')
plt.xlabel('Week')
plt.legend(title='Teamwork Group')
plt.xticks(rotation=45)
plt.grid(True, linestyle='--', alpha=0.4)
plt.tight_layout()
plt.show()

"""### 희생"""

# Sacrifice 상하위 25% 기준 계산
sacrifice_q75 = event_counts['Sacrifice'].quantile(0.75)
sacrifice_q25 = event_counts['Sacrifice'].quantile(0.25)

# 그룹 구분 함수 정의
def sacrifice_group(val):
    if val >= sacrifice_q75:
        return 'high'
    elif val <= sacrifice_q25:
        return 'low'
    else:
        return 'middle'

# 적용
event_counts['sacrifice_group'] = event_counts['Sacrifice'].apply(sacrifice_group)

# 병합
merged_sac = high_performers_df.merge(event_counts[['sub_ID', 'sacrifice_group']], on='sub_ID', how='left')

# 주차 생성
merged_sac['event_week'] = pd.to_datetime(merged_sac['event_date']).dt.to_period('W').dt.to_timestamp()

# 상하위 그룹만 필터링
filtered_sac = merged_sac[merged_sac['sacrifice_group'].isin(['high', 'low'])]

# 주차별 평균 efficacy 계산
sac_curve = filtered_sac.groupby(['event_week', 'sacrifice_group'])['actual_efficacy_h'].mean().reset_index()

plt.figure(figsize=(14, 6))
sns.lineplot(data=sac_curve, x='event_week', y='actual_efficacy_h', hue='sacrifice_group', palette='Dark2')
plt.title('Productivity Over Time: High vs Low Sacrifice Group')
plt.ylabel('Avg Actual Efficacy (h)')
plt.xlabel('Week')
plt.legend(title='Sacrifice Group')
plt.grid(True, linestyle='--', alpha=0.5)
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

"""# 7. 생산성 기준 관리 필요 고성과자 분류"""

high_performers_df.head(2)

high_performers_df.columns

high_performers_df.gropuby('sub_ID').agg

high_performer_avg_efficacy = high_performers_df.groupby('sub_ID').agg({'actual_efficacy_h': 'mean'}).reset_index()

high_performer_avg_efficacy['actual_efficacy_h'].sort_values(ascending=False)

efficacy_top_performers = high_performers_df[high_performers_df['actual_efficacy_h'] >= 2]

efficacy_top_performers.shape

top_df = efficacy_top_performers.groupby(by = 'sub_ID').agg({'actual_efficacy_h':'mean'}).reset_index()

top_df.head(2)

top_df.mean()

merge_top_df = pd.merge(top_df, high_performers_df, on='sub_ID', how='inner')

merge_top_df['sub_'].mean()

merge_top_df.columns

"""# 8. 성과 급등/급락 중인 직원

- 최근 1개월 efficacy 평균 구하기
- 최근 1개월 제외 efficacy 평균 구하기
- efficacy 평균이 지난 평균 대비 많이 올라간 5인
- efficacy 평균이 지난 평균 대비 많이 떨어진 5인
"""

recent_df.head(2)

# 월 정보 컬럼 추가
recent_df['month'] = recent_df['event_date'].dt.month

# 1~5월 평균 efficacy
jan_to_may = recent_df[recent_df['month'].between(1, 5)]
jan_may_avg = jan_to_may.groupby('sub_ID')['actual_efficacy_h'].mean().rename('avg_1_5')

# 6월 평균 efficacy
june = recent_df[recent_df['month'] == 6]
june_avg = june.groupby('sub_ID')['actual_efficacy_h'].mean().rename('avg_6')

# 두 결과 병합
efficacy_change = pd.concat([jan_may_avg, june_avg], axis=1).dropna()

# 변화량 계산
efficacy_change['diff'] = efficacy_change['avg_6'] - efficacy_change['avg_1_5']

# 많이 오른 5명
top_5_risers = efficacy_change.sort_values(by='diff', ascending=False).head(5)

# 많이 떨어진 5명
top_5_fallers = efficacy_change.sort_values(by='diff', ascending=True).head(5)

# 결과 확인
print("🔺 많이 오른 5명:")
print(top_5_risers)

print("\n🔻 많이 떨어진 5명:")
print(top_5_fallers)

# top 10명 sub_id 추출
top_10_ids = pd.concat([top_5_risers, top_5_fallers]).index.tolist()

# 원본에서 이 sub_id에 해당하는 사람 정보 추출 (6월 기준 가장 최신 데이터 한 줄만)
latest_info = (
    recent_df[recent_df['sub_ID'].isin(top_10_ids)]
    .sort_values(by='event_date', ascending=False)
    .drop_duplicates(subset='sub_ID')[['sub_ID', 'sub_fname', 'sub_lname', 'sub_shift', 'sub_team']]
    .set_index('sub_ID')
)

# 최종 병합
final_result = pd.concat([efficacy_change.loc[top_10_ids], latest_info], axis=1)

# 정렬 (diff 기준 오름차순 → 하락이 아래로)
final_result = final_result.sort_values(by='diff', ascending=False)

# 결과 출력
print(final_result)

